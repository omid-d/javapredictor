# راهنما شبیه‌ساز

## records, enums and...

در این قسمت، به داده‌ساختار‌های شبیه‌ساز موجود می‌پردازیم.

### Bit

یک داده‌ساختار ساده از جنس `enum`  می‌باشد که با استفاده از آن می‌توانید یک بیت را تعریف کنید.

این داده‌ساختار تابع‌های کمکی زیر را شامل می‌باشد:

`toNumber`: رشته‌ای از بیت‌ها را دریافت می‌کند و عدد مثبت متناظر با آن رشته را به شما برمی‌گرداند. دقت کنید که
پرارزش‌ترین بیت، اولین بیت آرایه می‌باشد یعنی `array[0]`.

`arrayToString`: یک آرایه از بیت‌ها را دریافت می‌کند و رشته متناظر با آن را برمی‌گرداند.
دقت کنید که پرارزش‌ترین بیت، اولین بیت آرایه یعنی `array[0]` می‌باشد.

### Branch Instruction

داده‌ساختار مربوط به دستورات `branch` می‌باشد که شامل:

<ol>
<li>
opcode : آپکود مربوط به دستورات پرش
</li>
<br>
<li>
instruction address : آدرسی که دستور پرش در آن ذخیره شده است.
</li>
<br>
<li>
jump address: آدرسی که در صورت برقراری شرط پرش یا نبود آن، مقدار program coutner را به آن تغییر می‌دهیم.
</li>

می‌باشد.

توابع کمکی این موجودیت `getter`های این فیلد‌ها می‌باشند.
</ol>

### Branch Result

یک داده‌ساختار از جنس `enum` که به کمک آن نتیجه `branch condition` تعیین می‌شود.
(`TAKEN` or `NOT_TAKEN`)

### Count Mode

یک داده‌ساختار از جنس `enum` می‌باشد که به کمک آن می‌توانید منطق شمارش یا به عبارتی نوع شمارنده را تعیین کنید.
لازم به ذکر است مواردی که باید تکمیل شوند تنها از نوع `SATURATING` استفاده می‌کنند و نیاز به پیاده‌سازی بقیه نوع‌ها یا استفاده‌ از آنها نمی‌باشد.


### Hash Mode

یک داده‌ساختار از جنس  `enum` می‌باشد که به کمک آن می‌توانید منطق هش یا به عبارتی نوع مدار مورد استفاده برای هش را تعیین کنید.
برای کمک به شما، یک نوع `hash` ساده با استفاده از تابع `xor` پیاده‌ شده است.


### Monitorable

یک داده‌ساختار از جنس `interface` می‌باشد. کلاس‌هایی که از این `interace` استفده می‌کنند، یک رشته شامل مقدار ذخیره شده در ثبات یا حافظه مربوط به آن مدل را برمی‌گرداند.

## devices

### Combinational Logic

یک `static class` می‌باشد که برای مدار‌های شمارنده و هش از آن استفاده می‌شود.

### Shift Register

یک داده‌ساختار از جنس `interface` می‌باشد که رفتار‌های یک `shift register` را شبیه‌سازی می‌کند.

`read`: محتویات آن ثبات را می‌خواند و به صورت رشته‌ای از بیت‌ها برمی‌گرداند.

`load`: یک مقدار را درون ثبات ذخیره می‌کند.

`insert`: یک بیت‌ دریافت کرده و با توجه به نوع ثبات، آن را ذخیره می‌کند.

`getLength`: طول ثبات را باز‌ می‌گرداند.

`clear`: مختویات درون ثابت را پاک می‌کند. 
(همه بیت‌ها صفر می‌شوند.)

### SIPO Register
یک نوع موجودیت است که رفتار مربوط به یک `serial-in parallel-out shift register` را شبیه‌سازی کرده است.

همانطور که از نام آن مشخص است، عملیات `read` تمامی‌ بیت‌های موجود در ثبات را به صورت موازی باز می‌گرداند. 

عملیات `insert` یک بیت را در اولین‌خانه از ثابت می‌نویسند و باقی بیت‌ها به سمت راست شیفت داده می‌شوند.

عملیات `load` یک مقدار را به صورت موازی در ثبات ذخیره می‌کند.

عملیات `clear` تمامی خانه‌های ثبات را صفر می‌کند.

عملیات `monitor` مقدار موجود در ثبات را باز می‌گرداند.

### Register Bank

یک نوع موجودیت برای مدل کردن `register bank` می‌باشد. 

`read` با دریافت بیت‌های `selector` یک ثبات را از بانک ثبات می‌خواند و آن را برمی‌گرداند.

دقت کنید که اگر ثباتی را تغییر دادید لازم است تا دوباره آن را با استفاده از دستور `write` در `register bank` بازنویسی کنید.

با استفاده از دستور `write` می‌توانید یک داده را با استفاده از `selector` در `register bank` ذخیره کنید.

### Cache 

یک داده‌ساختار از جنس `interface` می‌باشد که رفتار یک `cache` را شبیه‌سازی می‌کند.

لازم به ذکر است که این شبیه‌سازی بسیار ساده‌انگارانه می‌باشد تا از پیچیدگی‌های احتمالی جلوگیری کند.
در این پیاده‌سازی لازم نیست که شما آشنایی خاصی با سیاست بازیابی داده و یا نوشتن در `cache` داشته باشید.

<ul>

<li>get: با استفاده از یک کلید، مقدار نسبت داده شده به آن کلید را باز می‌گرداند</li>
<br>
<li>put: یک کلید را به یک مقدار نسبت می‌دهد</li>
<br>
<li>putIfAbsent: اگر کلید در کش موجود نبود، داده را به آن نسبت می‌دهیم.</li>
<br>
<li>setDefault: اگر کلید داده شده به مقداری نسبت داده شده باشند آن را برمی‌گرداند در غیر این صورت مقدار default را به آن کلید نسبت می‌دهد و آن را به عنوان خروجی برمی‌گرداند.

</li>

<br>
<li>
clear: مقادیر درون کش را پاک می‌کند
</li>
</ul>

### Predication History Table

یک نوع کش می‌باشد که در هر بلاک آن یک `saturating counter` قرار دارد. 

### Per Address Predication History Table

به صورت یک کش دو بعدی می‌باشد به عبارتی چند بیت اول کلید، کشی را تعیین می‌کنند که در آن داده قرار دارد و چند بیت بعدی کلید آن کش می‌باشند.



در این قسمت ابتدا به معرفی 